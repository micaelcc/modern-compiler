#include <stdio.h>
#include "repl/repl.h"
extern Token *TOKENS;

const char* get_filename_from_path(const char *path) {
    const char *slash = strrchr(path, '/');
    return (slash) ? slash + 1 : path;
}

char* build_output_report_filename(const char *input_path) {
    const char *filename = get_filename_from_path(input_path);
    size_t len = strlen(filename);
    
    const char *suffix = ".reports";
    size_t total_len = len + strlen(suffix) + 1;

    char *output = (char*) malloc(total_len);
    if (!output) {
        perror("malloc failed");
        return NULL;
    }

    strcpy(output, filename);
    strcat(output, suffix);

    return output;
}

void compile(char* file_path, CompilerOptions options) {
    char *file_code = read_file_to_string(file_path);

    if (options.EXECUTE_TABLE_DRIVEN) {
        load_file();
        set_table();
    }

    make_tokens(file_code);
    

    ParserBMark result = execute_parser_bmark(options);

    
    //printf(
    //    "Options: \n\t--only-syntax-check=%s\n\t--execute-table-driven=%s\n\t--execute-recursive-descent=%s\n"
    //    , options.ONLY_SYNTAX_CHECK ? "true" : "false", options.EXECUTE_TABLE_DRIVEN ? "true" : "false", options.EXECUTE_RECURSIVE_DESCENT ? "true" : "false");

    printf("Reports:\n");
    printf("\tFile: %s\n\tParser: %s\n\tTokens analyzed: %lu\n\tTime: %Lf (ms)\n\tMemory Consumption (KB)(VmRSS): %Lf\n\tMemory Consumption (HEAP)(KB): %Lf\n", file_path,result.parser, result.tokens_analyzed, result.time_in_ms, result.memory_consumption_in_KB, result.memory_heap_consumption_in_KB);
    if (!options.ONLY_SYNTAX_CHECK) {
        printf("Parse tree:\n");
        // printf("\t");
        // print_tree_inline(result.tree);
    }

    free(file_code);
    if (options.EXECUTE_TABLE_DRIVEN) free_table();
    free_tokens();
    //free_parse_tree(result.tree);
    // TODO semantic/backend
}
void print_help()
{
    printf("Usage: EasyCCompiler v0.0.0 [options]\n");
    printf("\nOptions:\n");
    printf("  -i, --input <file>            Load code from file and run\n");
    printf("  --print-parse-tree            Enable printing of parse tree\n");
    printf("  --execute-recursive-descent   Execute recursive descent parser\n");
    printf("  --execute-table-driven        Execute table-driven parser\n");
    printf("  --only-syntax-check           Only check syntax without executing\n");
    printf("  --print-tokens                Print tokens generated by lexer\n");
    printf("  -h, --help                   Display this help message\n");
    printf("\nIf no input file is provided, the program starts the REPL.\n");
}

int main(int argc, char *argv[])
{
    int i;
    CompilerOptions op = {false, false, false, false, false, false};
    for (i = 1; i < argc; i++)
    {
        if (strcmp(argv[i], "--input") == 0 || strcmp(argv[i], "-i") == 0)
        {
            i++;
            if (argv[i] == NULL){
                print_help();
                exit(1);
            }

            compile(argv[i], op);
            exit(0);
        }
        else if (strcmp(argv[i], "--print-parse-tree") == 0)
        {
            op.ONLY_SYNTAX_CHECK = false;
            op.PRINT_PARSE_TREE = true;
        }
        else if (strcmp(argv[i], "--execute-table-driven") == 0)
        {
            op.EXECUTE_TABLE_DRIVEN = true;
            op.EXECUTE_RECURSIVE_DESCENT = false;
        }
        else if (strcmp(argv[i], "--execute-recursive-descent") == 0)
        {
            op.EXECUTE_RECURSIVE_DESCENT = true;
            op.EXECUTE_TABLE_DRIVEN = false;
        }
        else if (strcmp(argv[i], "--print-tokens") == 0)
        {
            op.PRINT_TOKENS = true;
        }
        else if (strcmp(argv[i], "--only-syntax-check") == 0)
        {
            op.ONLY_SYNTAX_CHECK = true;
            op.PRINT_PARSE_TREE = true;
        }
        else
        {
            print_help();
            exit(1);
        }
    }
    if (!(op.EXECUTE_RECURSIVE_DESCENT || op.EXECUTE_TABLE_DRIVEN)) {
        op.EXECUTE_TABLE_DRIVEN = 1;
    }
        
    prompt(op);

    free_table();
    free_tokens();
    return 0;
}
